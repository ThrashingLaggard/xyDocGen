name: CI/CD for xyDocGen

# Trigger: Run on pushes to the "master" branch
on:
  push:
    branches:
      - master

permissions:
  contents: write

# ----------------------
# Concurrency control ensures only the latest run for the same
# workflow+ref is active; older in-progress runs are cancelled.
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true
# ----------------------

jobs:
  precheck:
    runs-on: ubuntu-latest
    # Expose results of the keyword scan to downstream jobs.
    # - should_run: "true"/"false" gate for the build job
    # - bump_kind:  "major" | "minor" | "patch" | "none"
    # - match_keyword: the exact keyword that triggered the bump ("BREAKING CHANGE" | "feat:" | "fix:" | "...")
    outputs:
      should_run:    ${{ steps.scan.outputs.should_run }}
      bump_kind:     ${{ steps.scan.outputs.bump_kind }}
      match_keyword: ${{ steps.scan.outputs.match_keyword }}
    steps:
      # Minimal checkout is sufficient for reading the latest commit message.
      - name: Checkout (shallow is fine)
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
      
      # Read the latest commit message exactly once.
      # This step is the *single source of truth* 
      - name: Scan latest commit message (case-insensitive)
        id: scan
        shell: bash
        run: |
          msg="$(git log -1 --pretty=%B)"
          
          echo "Commit message payload:"
          echo "-----------------------"
          echo "$msg"
          echo "-----------------------"
          echo

          bump_kind="none"
          match_keyword=""
          
          if echo "$msg" | grep -iqE '(^|[[:space:]])BREAKING[[:space:]]+CHANGE([[:space:]]|$)'; then
            bump_kind="major"; match_keyword="BREAKING CHANGE"
          elif echo "$msg" | grep -iqE '(^|[[:space:]])feat(\([^)]+\))?:'; then
            bump_kind="minor"; match_keyword="feat:"
          elif echo "$msg" | grep -iqE '(^|[[:space:]])fix(\([^)]+\))?:'; then
            bump_kind="patch"; match_keyword="fix:"
          fi
  
          if [ "$bump_kind" != "none" ]; then
            echo "Keyword matched: $match_keyword  -> bump_kind=$bump_kind"
            echo "should_run=true"        >> "$GITHUB_OUTPUT"
            echo "bump_kind=$bump_kind"   >> "$GITHUB_OUTPUT"
            echo "match_keyword=$match_keyword" >> "$GITHUB_OUTPUT"
          else
            echo "No matching keyword found -> should_run=false"
            echo "should_run=false"        >> "$GITHUB_OUTPUT"
            echo "bump_kind=none"          >> "$GITHUB_OUTPUT"
            echo "match_keyword="          >> "$GITHUB_OUTPUT"
          fi

  build-and-changed:
    needs: precheck
    runs-on: ubuntu-latest  # GitHub-hosted Ubuntu Linux runner

    # =========================================================
    # Hard gate at job level: only proceed if precheck decided so.
    # This prevents wasting minutes on runners when no publish-worthy
    # change was requested by commit message.
    # =========================================================
    if: needs.precheck.outputs.should_run == 'true'
    
    # Make precheck outputs available as environment variables to all steps.
    env:
      BUMP_KIND:     ${{ needs.precheck.outputs.bump_kind }}       # "major" | "minor" | "patch"
      MATCH_KEYWORD: ${{ needs.precheck.outputs.match_keyword }}   # e.g. "feat:" (diagnostics only)

    steps:
      # ------------------------------------------------------
      # 1) Checkout repository to get sources and Git history
      # ------------------------------------------------------
      - name: Checkout repository
        uses: actions/checkout@v4

      # ----------------------------------------------------------------
      # 2) Guard against double commits with identical messages (variant 2)
      #    This prevents accidental duplicate processing/publishing if the
      #    same commit message is pushed twice in a row.
      #    Exposes SKIP=true/false via GITHUB_ENV (used only for diagnostics;
      #    we still keep the hard gate at job-level to avoid wasted minutes).
      # ----------------------------------------------------------------
      - name: Guard – skip duplicate commit message
        id: guard
        shell: bash
        run: |
          # Ensure the last 2 commits are available
          git fetch --depth=2 origin ${{ github.ref }}

          m1="$(git log -1 --pretty=%B)"
          m2="$(git log -2 --pretty=%B | sed -n '2p')"

          if [ "$m1" = "$m2" ]; then
            echo "SKIP=true" >> "$GITHUB_ENV"
            echo "Duplicate commit message – skipping."
          else
            echo "SKIP=false" >> "$GITHUB_ENV"
          fi

      # -------------------------------------
      # 3) Install .NET 8 SDK for build/test
      # -------------------------------------
      - name: Setup .NET 8
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      # ----------------------------------------
      # 4) Restore NuGet dependencies for build
      # ----------------------------------------
      - name: Restore dependencies
        run: dotnet restore xyDocGen/xyDocumentor.csproj

      # --------------------------------------------------------------------
      # 5) Compute next semantic version **using BUMP_KIND from precheck**.
      #
      #    Primary path:
      #      - Trust BUMP_KIND (authoritative result from precheck)
      #        * major -> major++, minor=0, patch=0
      #        * minor -> minor++, patch=0
      #        * patch -> patch++
      #
      #    Defensive fallback (one-time, in case env is unexpectedly empty):
      #      - Re-scan the latest commit message with the same rules to
      #        determine a bump kind. This keeps the pipeline robust against
      #        environment/output mishaps without double-scanning in normal runs.
      #
      #    The final version is exported as env.version (GITHUB_ENV).
      # --------------------------------------------------------------------
      - name: Generate new version from prechecked bump kind (with fallback)
        id: versioning
        shell: bash
        run: |
          # Read current version from .csproj
          current_version=$(grep -oPm1 "(?<=<PackageVersion>)[^<]+" xyDocGen/xyDocumentor.csproj)
          echo "Current version: $current_version"

          # Parse current version into components (major.minor.patch)
          major=$(echo "$current_version" | cut -d. -f1)
          minor=$(echo "$current_version" | cut -d. -f2)
          patch=$(echo "$current_version" | cut -d. -f3)

          # Use authoritative bump kind from precheck if available
          bump="${BUMP_KIND:-}"

          # --------- Fallback: recompute once if bump is empty ----------
          if [ -z "$bump" ] || [ "$bump" = "none" ]; then
            echo "BUMP_KIND not set or 'none' – performing defensive one-time rescan."
            commits="$(git log -1 --pretty=%B)"

            if echo "$commits" | grep -iqE '(^|[[:space:]])BREAKING[[:space:]]+CHANGE([[:space:]]|$)'; then
              bump="major"
            elif echo "$commits" | grep -iqE '(^|[[:space:]])feat(\([^)]+\))?:'; then
              bump="minor"
            elif echo "$commits" | grep -iqE '(^|[[:space:]])fix(\([^)]+\))?:'; then
              bump="patch"
            else # Secondary fallback: flatten newlines and re-check (handles unusual formatting)
              flat="$(echo "$commits" | tr '\n' ' ')"
              if echo "$flat" | grep -iqE 'BREAKING[[:space:]]+CHANGE'; then
                bump="major"
              elif echo "$flat" | grep -iqE 'feat(\([^)]+\))?:'; then
                bump="minor"
              elif echo "$flat" | grep -iqE 'fix(\([^)]+\))?:'; then
                bump="patch"
              else # If still nothing, keep current version unchanged.
                echo "No semantic keyword found even after fallback scan – keeping current version."
                bump="none"
              fi
            fi
          fi
          # ----------------------------------------------------------------

          # Apply bump according to resolved 'bump'
          case "$bump" in
            major)
              major=$((major + 1))
              minor=0
              patch=0
              echo "Applying MAJOR bump (breaks API/compat)."
              ;;
            minor)
              minor=$((minor + 1))
              patch=0
              echo "Applying MINOR bump (new feature, backward compatible)."
              ;;
            patch)
              patch=$((patch + 1))
              echo "Applying PATCH bump (bug fix, backward compatible)."
              ;;
            *)
              echo "No bump requested – version remains unchanged."
              ;;
          esac

          new_version="$major.$minor.$patch"
          echo "New version: $new_version"

          # Export for downstream steps
          echo "version=$new_version" >> "$GITHUB_ENV"

      # ----------------------------------------------------------------
      # 6) Update the PackageVersion in the .csproj with the new version
      # ----------------------------------------------------------------
      - name: Update .csproj with new version
        shell: bash
        run: |
          sed -i "s/<PackageVersion>.*<\/PackageVersion>/<PackageVersion>${{ env.version }}<\/PackageVersion>/" xyDocGen/xyDocumentor.csproj

      # -------------------------------------------------------------------
      # 7) Commit and push the version bump (if there is a change to commit)
      #    "continue-on-error" is kept to avoid failing the pipeline if the
      #    push races with another run.
      # -------------------------------------------------------------------
      - name: Commit updated version
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git pull --ff-only origin master
          git add xyDocGen/xyDocumentor.csproj

          if git diff --cached --quiet; then
            echo "Nothing to commit – skipping."
          else
            git commit -m "chore: bump version to ${{ env.version }}"
            git push origin master
            echo "Changes committed and pushed."
          fi
        continue-on-error: true

      # --------------------------------
      # 8) Build the project (Release)
      # --------------------------------
      - name: Build xyDocGen
        run: dotnet build xyDocGen/xyDocumentor.csproj --configuration Release --no-restore

      # ------------------------------
      # 9) Run unit tests (no build)
      # ------------------------------
      - name: Test xyDocGen
        run: dotnet test xyDocGen/xyDocumentor.csproj --no-build --verbosity detailed # quiet|minimal|normal|detailed|diagnostic

      # ---------------------------------------------
      # 10) Pack the NuGet package into ./out folder
      # ---------------------------------------------
      - name: Pack NuGet package
        run: dotnet pack xyDocGen/xyDocumentor.csproj --configuration Release --no-build -o out

      # -------------------------------------------------------------------
      # 11) Check whether the package version already exists on nuget.org
      #     If it exists, skip publish and release creation.
      # -------------------------------------------------------------------
      - name: Check package version exists
        id: check_version
        shell: bash
        run: |
          version=$(grep -oPm1 "(?<=<PackageVersion>)[^<]+" xyDocGen/xyDocumentor.csproj)
          echo "Detected version: $version"

          content_type=$(curl -sI -o /dev/null -w "%{content_type}" \
            "https://api.nuget.org/v3-flatcontainer/xydocgen/$version/xydocgen.$version.nupkg")

          if [[ "$content_type" == "application/octet-stream" ]]; then
            echo "Package version $version already exists. Skipping publish."
            echo "skip_publish=true" >> "$GITHUB_OUTPUT"
          else
            echo "Package version $version not found. Proceeding to publish."
            echo "skip_publish=false" >> "$GITHUB_OUTPUT"
          fi

      # --------------------------------------------------------------
      # 12) Push the package to NuGet (only if not already published)
      # --------------------------------------------------------------
      - name: Push to NuGet
        if: steps.check_version.outputs.skip_publish == 'false'
        run: >
          dotnet nuget push out/*.nupkg
          --source https://api.nuget.org/v3/index.json
          --api-key ${{ secrets.XYDOCGEN_API_KEY }}
          --skip-duplicate

      # --------------------------------------------------------------
      # 13) Create a GitHub Release for the new version (if published)
      # --------------------------------------------------------------
      - name: Create GitHub Release
        if: steps.check_version.outputs.skip_publish == 'false'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ env.version }}
          name: Release ${{ env.version }}
          body: |
            Bump kind: ${{ env.BUMP_KIND }}
            Triggered by keyword: ${{ env.MATCH_KEYWORD }}
          draft: false
          prerelease: false
