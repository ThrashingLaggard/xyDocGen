using System.Collections.Generic;
using System.Linq;
using System.Text;
using xyDocumentor.Core.Docs;

namespace xyDocumentor.Core.Renderer
{
    /// <summary>
    /// Provides static methods to generate structured code documentation
    /// in Markdown format.
    /// </summary>
    public static class MarkdownRenderer
    {
        /// <summary>
        /// Renders a TypeDoc object and all its nested types recursively
        /// into a Markdown string.
        /// </summary>
        /// <param name="type">The TypeDoc object to be rendered.</param>
        /// <param name="level">The starting heading level for the Markdown output (e.g., 1 for #, 2 for ##).</param>
        /// <returns>A string containing the generated Markdown documentation.</returns>
        public static string Render(TypeDoc type, int level = 1)
        {
            // The StringBuilder is used for efficient string manipulation and building.
            var sb = new StringBuilder();

            // Each section of the documentation is generated by a separate, dedicated method.
            RenderHeader(sb, type, level);
            RenderMetadata(sb, type);
            RenderDescription(sb, type);
            RenderAllMembers(sb, type);
            RenderNestedTypes(sb, type, level);

            // Returns the final Markdown string, removing any leading or trailing whitespace.
            return sb.ToString().Trim();
        }

        // --- Private helper methods for better structure and readability ---

        /// <summary>
        /// Renders the main header for the type, including its kind and display name.
        /// </summary>
        /// <param name="sb">The StringBuilder to append to.</param>
        /// <param name="type">The TypeDoc object containing the data.</param>
        /// <param name="level">The heading level for the Markdown output.</param>
        private static void RenderHeader(StringBuilder sb, TypeDoc type, int level)
        {
            // Creates the heading prefix (e.g., "#", "##", "###") based on the level.
            string headingPrefix = new string('#', level);
            sb.AppendLine($"{headingPrefix} {type.Kind} `{type.DisplayName}`");
            sb.AppendLine();
        }

        /// <summary>
        /// Renders the metadata section for the type.
        /// </summary>
        /// <param name="sb">The StringBuilder to append to.</param>
        /// <param name="type">The TypeDoc object containing the data.</param>
        private static void RenderMetadata(StringBuilder sb, TypeDoc type)
        {
            sb.AppendLine("## Metadata");
            sb.AppendLine($"**Namespace:** `{type.Namespace}`");
            sb.AppendLine($"**Visibility:** `{type.Modifiers}`");

            // Helper method simplifies adding lists of metadata, such as attributes or base types.
            AppendMetadataList(sb, "Attributes", type.Attributes);
            AppendMetadataList(sb, "Base Classes/Interfaces", type.BaseTypes);

            sb.AppendLine($"**Source File:** `{type.FilePath}`");
            sb.AppendLine();
        }

        /// <summary>
        /// Appends a list of metadata items to the StringBuilder only if the list is not empty.
        /// </summary>
        /// <param name="sb">The StringBuilder to append to.</param>
        /// <param name="title">The title for the list (e.g., "Attributes").</param>
        /// <param name="items">The list of strings to be appended.</param>
        private static void AppendMetadataList(StringBuilder sb, string title, IReadOnlyList<string> items)
        {
            // Checks if the list exists and contains any elements.
            if (items?.Any() == true)
            {
                // Formats each item as inline code for better readability in Markdown.
                var formattedItems = items.Select(item => $"`{item}`");
                sb.AppendLine($"**{title}:** {string.Join(", ", formattedItems)}");
            }
        }

        /// <summary>
        /// Renders the summary or description section for the type.
        /// </summary>
        /// <param name="sb">The StringBuilder to append to.</param>
        /// <param name="type">The TypeDoc object containing the data.</param>
        private static void RenderDescription(StringBuilder sb, TypeDoc type)
        {
            sb.AppendLine("## Description");
            // Appends the summary if it's not null or whitespace.
            if (!string.IsNullOrWhiteSpace(type.Summary))
            {
                sb.AppendLine(type.Summary.Trim());
            }
            else
            {
                // A placeholder is added if no description is available.
                sb.AppendLine("_No description available._");
            }
            sb.AppendLine();
        }

        /// <summary>
        /// Calls the rendering methods for all member types (constructors, properties, methods, etc.).
        /// </summary>
        /// <param name="sb">The StringBuilder to append to.</param>
        /// <param name="type">The TypeDoc object containing the data.</param>
        private static void RenderAllMembers(StringBuilder sb, TypeDoc type)
        {
            RenderMembersAsTable(sb, "Constructors", type.Constructors);
            RenderMembersAsTable(sb, "Properties", type.Properties);
            RenderMembersAsTable(sb, "Methods", type.Methods);
            RenderMembersAsTable(sb, "Events", type.Events);
            RenderMembersAsTable(sb, "Fields", type.Fields);
        }

        /// <summary>
        /// Renders a list of members (methods, properties, etc.) as a clear Markdown table.
        /// </summary>
        /// <param name="sb">The StringBuilder to append to.</param>
        /// <param name="title">The title for the member table (e.g., "Methods").</param>
        /// <param name="members">The list of MemberDoc objects to be rendered.</param>
        private static void RenderMembersAsTable(StringBuilder sb, string title, IReadOnlyList<MemberDoc> members)
        {
            // If the list is empty or null, nothing is rendered.
            if (members?.Any() != true) return;

            sb.AppendLine($"## {title}");
            sb.AppendLine();

            // Renders the table header for Signature and Description columns.
            sb.AppendLine("| Signature | Description |");
            sb.AppendLine("|-----------|-------------|");

            // Iterates through each member to create a new table row.
            foreach (var member in members)
            {
                // Cleans up the summary for display in a single table row by removing newlines.
                var summary = member.Summary?.Trim().Replace("\r\n", " ").Replace("\n", " ")
                                     ?? "_No description._";

                sb.AppendLine($"| `{member.Signature}` | {summary} |");
            }
            sb.AppendLine();
        }

        /// <summary>
        /// Renders all nested types contained within the current type.
        /// </summary>
        /// <param name="sb">The StringBuilder to append to.</param>
        /// <param name="type">The TypeDoc object containing the data.</param>
        /// <param name="level">The heading level for the Markdown output.</param>
        private static void RenderNestedTypes(StringBuilder sb, TypeDoc type, int level)
        {
            // FlattenNested() returns the type itself and all nested types.
            // Skip(1) skips the root element so we only process the nested types.
            var nestedTypes = type.FlattenNested().Skip(1);
            if (!nestedTypes.Any()) return;

            sb.AppendLine("---"); // A horizontal rule for better readability.

            foreach (var nested in nestedTypes)
            {
                // Recursively calls the Render method for the nested type, incrementing the heading level.
                sb.AppendLine(Render(nested, level + 1));
                sb.AppendLine();
            }
        }
    }
}




//using System.Collections.Generic;
//using System.Linq;
//using System.Text;
//using xyDocGen.Core.Docs;

//namespace xyDocGen.Core.Renderer
//{
//    /// <summary>
//    /// Rendering the documentation in Markdown file
//    /// </summary>
//    public static class MarkdownRenderer
//    {
//        /// <summary>
//        /// Renders a TypeDoc object as Markdown, including all nested types recursively.
//        /// </summary>
//        public static string Render(TypeDoc type, int level = 1)
//        {
//            var sb = new StringBuilder();
//            string headingPrefix = new string('#', level);

//            // Header
//            sb.AppendLine($"{headingPrefix} {type.Kind} {type.DisplayName}");
//            sb.AppendLine();
//            sb.AppendLine();

//            // Metadata
//            sb.AppendLine($"**Namespace:** {type.Namespace}  ");
//            sb.AppendLine($"**Visibility:** {type.Modifiers}  ");
//            sb.AppendLine();
//            if (type.Attributes?.Count > 0)
//            {
//                sb.AppendLine($"**Attributes:** {string.Join(", ", type.Attributes)}  ");
//                sb.AppendLine();
//            }
//            if (type.BaseTypes?.Count > 0)
//            {
//                sb.AppendLine($"**Base/Interfaces:** {string.Join(", ", type.BaseTypes)}  ");
//                sb.AppendLine();
//            }
//            sb.AppendLine($"**Source:** {type.FilePath}  ");
//            sb.AppendLine();
//            sb.AppendLine();

//            // Description
//            sb.AppendLine("**Description:**");
//            sb.AppendLine();
//            if (!string.IsNullOrWhiteSpace(type.Summary))
//            {
//                sb.AppendLine(type.Summary.Trim());
//            }
//            else
//            {
//                sb.AppendLine("_No description._");
//            }
//            sb.AppendLine();
//            sb.AppendLine();

//            // Helper to render member lists with extra spacing between groups
//            void RenderMembers(string title, List<MemberDoc> members)
//            {
//                if (members == null || !members.Any()) return;

//                sb.AppendLine($"### {title}");
//                sb.AppendLine();
//                foreach (var m in members)
//                {
//                    sb.AppendLine($"- **{m.Kind}:** `{m.Signature}`");
//                    if (!string.IsNullOrWhiteSpace(m.Summary))
//                    {
//                        var summary = m.Summary.Trim().Replace("\r\n", " ").Replace("\n", " ");
//                        sb.AppendLine($"  - {summary}");
//                    }
//                    sb.AppendLine();
//                    sb.AppendLine();
//                }
//                sb.AppendLine();
//            }

//            RenderMembers("Constructors", type.Constructors);
//            RenderMembers("Methods", type.Methods);
//            RenderMembers("Properties", type.Properties);
//            RenderMembers("Events", type.Events);
//            RenderMembers("Fields", type.Fields);

//            // Nested types (recursive) with spacing
//            foreach (var nested in type.FlattenNested().Skip(1)) // skip self
//            {
//                sb.AppendLine();
//                sb.AppendLine(Render(nested, level + 1).TrimEnd());
//                sb.AppendLine();
//            }

//            return sb.ToString().TrimEnd();
//        }
//    }
//}
